/*
 * CPSDataProduct.c
 *
 *  Created on: Jan 18, 2019
 *      Author: gstoddard
 */

#include "CPSDataProduct.h"

//File-Scope Variables
static unsigned int first_FPGA_time;				//the first FPGA time we register for the run //sync with REAL TIME
static unsigned int m_previous_1sec_interval_time;	//the previous 1 second interval "start" time
static float m_num_intervals_elapsed;				//how many intervals have elapsed during the current run (effectively one/sec)
static CPS_EVENT_STRUCT_TYPE cpsEvent;				//the most recent CPS "event" (1 second of counts)
static const CPS_EVENT_STRUCT_TYPE cpsEmptyStruct;	//an empty 'zero' struct to init or clear other structs

static XTime cps_t_elapsed;	//was LocalTime
static XTime cps_t_next_interval;	//added to take the place of t_elapsed
static XTime cps_t_start;	//was LocalTimeStart
static XTime cps_t_current;	//was LocalTimeCurrent

static unsigned int m_first_check;
static int m_current_module_temp;

static double a_rad_1[4];		//semi-major axis
static double b_rad_1[4];		//semi-minor axis
static double mean_psd_1[4];	//Y center of the ellipse
static double mean_nrg_1[4];	//X center of the ellipse

/* Temperature Correction Value Arrays
 * 2-D arrays example:
 * my_array[det_num][module_num];
 * where det_num 	= detector number: 0, 1 based on MNS_DETECTOR_NUM defined in lunah_defines
 * where module_num = CLYC module number: 0 - 3 and each is recalculated when the temp changes
 * These parameters are current as of 1-22-2020 // The previous coefficients are deprecated as of 1-22-2020
 * These coefficients were generated by Erik  and are for the Flight Unit modules
 */
static double MinNRG_C0[2][4] = {{ 93.2258, 90.8032, 88.5955, 90.768 },{ 78.3005, 88.7147, 80.5706, 86.3289 }};
static double MinNRG_C1[2][4] = {{ 2.05662, 1.81035, 1.98898, 2.28579 },{ 1.53629, 1.61682, 2.4104, 1.8043 }};
static double MaxNRG_C0[2][4] = {{ 121.735, 119.324, 120.516, 126.826 },{ 112.667, 119.099, 125.251, 125.463 }};
static double MaxNRG_C1[2][4] = {{ 2.51537, 1.94239, 2.41405, 3.04624 },{ 1.69547, 2.11881, 3.19429, 2.34191 }};
static double MinPSD_C0[2][4] = {{ 3.40538, 4.2209, 3.31964, 4.93381 },{ 6.08188, 3.58617, 3.5529, 3.50813 }};
static double MinPSD_C1[2][4] = {{ 0.0360485, 0.0254763, 0.0406438, 0.0169089 },{ 0.0297649, 0.0310933, 0.04789, 0.0361139 }};
static double MinPSD_C2[2][4] = {{ 0.000192926, 0.000192633, -4.3401e-006, 0.000633796 },{ -0.000384863, 7.77722e-005, -0.000335611, 9.93544e-005 }};
static double MaxPSD_C0[2][4] = {{ 11.7918, 11.886, 11.7809, 12.3862 },{ 13.7109, 11.2853, 11.6923, 11.6875 }};
static double MaxPSD_C1[2][4] = {{ -0.0674961, -0.110337, -0.0786917, -0.124806 },{ -0.142347, -0.0581908, -0.0982008, -0.0627177 }};
static double MaxPSD_C2[2][4] = {{ 0.00122686, 0.00227616, 0.00144319, 0.0023301 },{ 0.00367359, 0.00116983, 0.0021518, 0.0010931 }};

static CONFIG_STRUCT_TYPE m_cfg_buff;	//172 bytes

/*
 * Reset the counts per second data product counters and event structures for the run.
 * Call this function before each DAQ run.
 *
 * @return	none
 *
 */
void CPSInit( void )
{
	cpsEvent = cpsEmptyStruct;
	first_FPGA_time = 0;
	m_previous_1sec_interval_time = 0;
	m_num_intervals_elapsed = 0;
	//get the user-supplied neutron cuts
	m_cfg_buff = *GetConfigBuffer();
	m_current_module_temp = GetModuTemp();

	return;
}

void CPSResetCounts( void )
{
	cpsEvent = cpsEmptyStruct;
	return;
}

void cpsSetFirstEventTime( unsigned int time )
{
	first_FPGA_time = time;
	return;
}

unsigned int cpsGetFirstEventTime( void )
{
	return first_FPGA_time;
}

unsigned int cpsGetCurrentTime( void )
{
	return (convertToSeconds(first_FPGA_time) + m_num_intervals_elapsed);
}

/*
 * Initialize cps_t_start and cps_t_elapsed at startup
 */
void cpsInitStartTime(void)
{
	XTime_GetTime(&cps_t_start);	//get the time
	cps_t_next_interval = 0;
}

/*
 * Helper function to convert the FPGA time from clock cycles to seconds
 *
 * @param	The integer time from the FPGA
 *
 * @return	The converted time in seconds
 */
float convertToSeconds( unsigned int time )
{
	return ((float)time * 0.000262144);
}

/*
 * Helper function to convert the number of elapsed 1s intervals into clock cycles.
 * This function converts from seconds -> clock cycles, then drops off any remainder
 *  by casting to unsigned int.
 *
 * @param	the floating point time to convert
 *
 * @return	the converted number of cycles
 */
unsigned int convertToCycles( float time )
{
	return (unsigned int)(time / 0.000262144);
}

/*
 * Helper function to compare the time of the event which was just read in
 *  to the time which defined the start of our last 1 second interval.
 * This will get called every time we get a full buffer and there is valid
 *  data within the buffer. When that happens, this will compare the time
 *  from the event to the current 1 second interval to see if the event falls
 *  within that time frame. If it does, move on and add the counts to the interval.
 *  If it does not fall within the interval, record that CPS event and go to
 *  the next one. Continue this process until the time falls within an interval.
 *
 * @param	The FPGA time from the event
 *
 * @return	TRUE if we need to record the CPS event, FALSE if not
 * 			A return value of TRUE will call this function again.
 */
bool cpsCheckTime( unsigned int time )
{
	bool mybool = FALSE;

	//for this function, we define the 1 second intervals for the entire run off
	// of the first event time that comes in from the FPGA
	//thus, if the event is within the interval defined by first_evt_time -> first_evt_time + 1.0
	// then it should be included with that CPS event
	//otherwise, report that 1 second interval and move to the next interval,
	// then check if the event goes into that interval
	//repeat this process until an interval is found
	//Intervals with 0 events in them are still valid
	if(convertToSeconds(time) >= (convertToSeconds(first_FPGA_time) + m_num_intervals_elapsed))
	{
		//this means that it does not fall within the current 1s interval
		//record the start time of this interval
		m_previous_1sec_interval_time = first_FPGA_time + convertToCycles(m_num_intervals_elapsed);
		//increase the number of intervals elapsed
		m_num_intervals_elapsed++;
		mybool = TRUE;
	}
	else
		mybool = FALSE;	//still within the current interval

	return mybool;
}

/*
 * Getter function for retrieving the most recent CPS "event". This function
 *  returns a pointer to the struct after updating it with the most up-to-date
 *  information regarding the DAQ run.
 *
 * We clear the entire structure after each one-second interval elapses, then
 *  the values for each PMT get populated as the buffers are processed. This
 *  means that the only numbers which need to get re-written are the event ID,
 *  the time, and the temperature.
 *
 * @param	None
 *
 * @return	Pointer to a CPS Event held in a struct
 */
CPS_EVENT_STRUCT_TYPE * cpsGetEvent( void )
{
	cpsEvent.event_id = 0x55;	//use the APID for CPS
	cpsEvent.modu_temp = (char)GetModuTemp();
	cpsEvent.pad_byte_1 = 0x55;	//use the APID for CPS
	cpsEvent.pad_byte_2 = 0x55;	//use the APID for CPS
	cpsEvent.time = m_previous_1sec_interval_time;

	return &cpsEvent;
}

/*
 * Helper function which takes in the energy, psd, module number, and the ellipse numbers and calculates the
 *  equations for the ellipses. Then it does the comparison to see if the point (energy, psd) is within the
 *  bounding ellipses.
 *
 * TODO: clean up the first few lines of this function - they can be performed less often if held as static variables
 * 			and calculated with the other neutron cut window parameters
 * TODO: move away from the sqrt() function and instead work with squares; trig and some math functions are time
 * 			and processor expensive
 *
 *  @param	(double) the baseline corrected energy value
 *  @param	(double) the baseline corrected PSD value
 *  @param	(int) the module number which has registered the event
 *  @param	(int) the ellipse number which chooses which cut parameters to apply
 *
 *  @return	(bool) TRUE if the event was within the defined ellipse
 *  			   FALSE if the event was not within the ellipse
 *
 */
bool CPSIsWithinEllipse( int energy, int psd, int pmt_id, int module_num, int ellipse_num )
{
	bool ret = FALSE;
	double c1 = (m_cfg_buff.SF_PSD[ellipse_num] * b_rad_1[module_num]) / (m_cfg_buff.SF_E[ellipse_num] * a_rad_1[module_num]);
	double c2 = m_cfg_buff.SF_E[ellipse_num] * a_rad_1[module_num];
	double xco = mean_nrg_1[module_num] + m_cfg_buff.Off_E[ellipse_num];
	//TODO: how do I resolve this type mis-match?
	double xval = (double)energy - xco;
	double yval = (double)psd	- mean_psd_1[module_num] - m_cfg_buff.Off_PSD[ellipse_num];

	//check x-coords
	//if this inequality is not met, then we cannot check y-coords or we will square root a negative number
	if(energy < xco + c2 && energy > xco - c2)
	{
		//check y-coords
		if(	yval <  c1 * sqrt( c2 * c2 - xval * xval) && yval > -c1 * sqrt( c2 * c2 - xval * xval))
		{
			//add a count to the appropriate CPS event field //this is based on PMT ID and ellipse number
			ret = TRUE;
			switch(pmt_id)
			{
			case PMT_ID_0:
				if(ellipse_num % 2 == 0)
					cpsEvent.n_ellipse1_0++;
				else
					cpsEvent.n_ellipse2_0++;
				break;
			case PMT_ID_1:
				if(ellipse_num % 2 == 0)
					cpsEvent.n_ellipse1_1++;
				else
					cpsEvent.n_ellipse2_1++;
				break;
			case PMT_ID_2:
				if(ellipse_num % 2 == 0)
					cpsEvent.n_ellipse1_2++;
				else
					cpsEvent.n_ellipse2_2++;
				break;
			case PMT_ID_3:
				if(ellipse_num % 2 == 0)
					cpsEvent.n_ellipse1_3++;
				else
					cpsEvent.n_ellipse2_3++;
				break;
			default:
				//what to do if we get a bad PMT ID?
				ret = FALSE;
				break;
			}
		}
		else
		{
			ret = FALSE;
		}
	}

	return ret;
}

//	 * unsigned short m_neutrons_ellipse1;		//neutrons with PSD
//	 * unsigned short m_neutrons_ellipse2;		//neutrons wide cut
//	 * unsigned short m_non_neutron_events;		//all non-neutron events total
//	 * unsigned short m_events_over_threshold;	//count all events which trigger the system

/*
 * Access function to update the tallies that we add each time we process an event. We store the
 *  various neutron totals in this module and use this function to update them. This function has access
 *  to the static neutron totals in this module and adds to them after running the input energy and psd
 *  value through the neutron cut values.
 * The neutron cut values are set and changed via the MNS_NGATES command.
 * This function gets the values from the temperature sensors every 10s and uses those temperatures
 *  to move the cutting ellipses around within the run. This way, we can maintain good data
 *  acquisition during a run when the temperature is not guaranteed to be constant.
 *
 * This approach moves away from the previously defined "box" cuts. The values and ranges from using
 *  that approach will be removed once this method is implemented and tested.
 *
 * The first time that this function is visited, the neutron cuts will be calculated, then once every 10s
 *  the module temperature will be re-measured and the cuts will be re-calculated.
 *
 * This function is going to use the current temperature of the module temperature sensor to calculate
 *  the neutron cuts. This should give us a good enough approximation of what the correct temperature is.
 *  In the next iteration, it would be good to utilize an array of the temperatures from the module
 *  temperature sensor. This way we can use the temperature which is from the actual time the data was taken
 *  and not just the current sensor temperature, which could be more recent than the data was taken in
 *  a low rate environment.
 *
 * NB: The wide	cut ellipse is currently hard-coded to be 20% larger in each dimension than the first ellipse.
 *
 * NB: This function has specially defined values in the header for this file. Change those values to
 * 		affect these cuts. Once we implement the elliptical cuts, we'll get rid of those values.
 *
 *
 * @param	(int) value for the energy calculated from the Full Integral from the event
 * @param	(int) value for the PSD calculated from the short and long integrals from the event
 *
 * @return	(int) 	returns a 1 if there was a hit in the primary or secondary neutron cut windows
 * 					0 if no hit was found
 * 					-1 if there was an error with the PMT hit ID
 */
int CPSUpdateTallies(int energy_bin, int psd_bin, int pmt_id)
{
	int status = 0;
	int iter = 0;
	int check_temp = 0;
	int module_id_num = 0;
	int ell_1 = 0;
	int ell_2 = 0;
	int n_detected_ell_1 = 0;
	int n_detected_ell_2 = 0;
	int n_high_e = 0;
	int non_n_event = 0;
	double MaxNRG = 0;
	double MinNRG = 0;
	double MaxPSD = 0;
	double MinPSD = 0;

	//check the temperature if it has been ~10s
	XTime_GetTime(&cps_t_current);
	cps_t_elapsed = (cps_t_current - cps_t_start)/COUNTS_PER_SECOND;
	if(cps_t_elapsed >= cps_t_next_interval)
	{
		while(cps_t_elapsed >= cps_t_next_interval)
		{
			cps_t_next_interval += 10;	//this value is how long we will wait in between checks on the temperature
		}

		check_temp = GetModuTemp();
		//if the temp has not changed, then we can just skip this
		//if the temp doesn't match or we haven't checked yet, then we are guaranteed to update the cut parameters
		if(m_current_module_temp != check_temp || m_first_check == 0)
		{
			m_current_module_temp = check_temp;
			//Calculate the values for the cuts to used
			//This is based on the temperature, which is the driver for where the cuts should be.
			//The other driver is the module number, as each module has different cuts.
			//basic equation:
			// E   = table_val0 + table_val1*temp^1
			// PSD = table_val0 + table_val1*temp^1 + table_val2*temp^2
			//calculate the ellipse parameters
			for(iter = 0; iter < 4; iter++)
			{
				MinNRG = MinNRG_C0[MNS_DETECTOR_NUM][iter] + MinNRG_C1[MNS_DETECTOR_NUM][iter]*m_current_module_temp;
				MaxNRG = MaxNRG_C0[MNS_DETECTOR_NUM][iter] + MaxNRG_C1[MNS_DETECTOR_NUM][iter]*m_current_module_temp;
				MinPSD = MinPSD_C0[MNS_DETECTOR_NUM][iter] + MinPSD_C1[MNS_DETECTOR_NUM][iter]*m_current_module_temp + MinPSD_C2[MNS_DETECTOR_NUM][iter]*m_current_module_temp*m_current_module_temp;
				MaxPSD = MaxPSD_C0[MNS_DETECTOR_NUM][iter] + MaxPSD_C1[MNS_DETECTOR_NUM][iter]*m_current_module_temp + MaxPSD_C2[MNS_DETECTOR_NUM][iter]*m_current_module_temp*m_current_module_temp;

				MinPSD *= (double)TWODH_Y_BINS / (double)TWODH_PSD_MAX;
				MaxPSD *= (double)TWODH_Y_BINS / (double)TWODH_PSD_MAX;
				//calculate the parameters
				//will need to modify these parameters with the scale factor & offset values from setIntstrumentParams
				a_rad_1[iter] =	 (MaxNRG - MinNRG) / 2.0;	// a, semi-major axis
				b_rad_1[iter] =	 (MaxPSD - MinPSD) / 2.0;	// b, semi-minor axis
				mean_nrg_1[iter] = (MaxNRG + MinNRG) / 2.0;	// X center
				mean_psd_1[iter] = (MaxPSD + MinPSD) / 2.0;	// Y center
			}
			//indicate that we have checked (and set) these parameters at least once
			m_first_check = 1;
		}
	}

	//compare energy, psd values to the cuts //tally if inside, otherwise no tally
	///////////
	//NOTE: if the pmt ID number is not a single hit, then we won't add it to the tallies
	///////////
	switch(pmt_id)
	{
	case PMT_ID_0:
		module_id_num = 0;
		ell_1 = 0;
		ell_2 = 1;
		if(energy_bin >= TWODH_X_BINS)
		{
			cpsEvent.high_energy_events_0++;
			n_high_e = 1;
		}
		break;
	case PMT_ID_1:
		module_id_num = 1;
		ell_1 = 2;
		ell_2 = 3;
		if(energy_bin >= TWODH_X_BINS)
		{
			cpsEvent.high_energy_events_1++;
			n_high_e = 1;
		}
		break;
	case PMT_ID_2:
		module_id_num = 2;
		ell_1 = 4;
		ell_2 = 5;
		if(energy_bin >= TWODH_X_BINS)
		{
			cpsEvent.high_energy_events_2++;
			n_high_e = 1;
		}
		break;
	case PMT_ID_3:
		module_id_num = 3;
		ell_1 = 6;
		ell_2 = 7;
		if(energy_bin >= TWODH_X_BINS)
		{
			cpsEvent.high_energy_events_3++;
			n_high_e = 1;
		}
		break;
	default:
		n_high_e = 0;
		status = -1;
		break;
	}

	if(status != -1)
	{
		if(	CPSIsWithinEllipse(energy_bin, psd_bin, pmt_id, module_id_num, ell_1) == TRUE)
			n_detected_ell_1 = 1;
		else
			n_detected_ell_1 = 0;

		if( CPSIsWithinEllipse(energy_bin, psd_bin,  pmt_id, module_id_num, ell_2) == TRUE)
			n_detected_ell_2 = 1;
		else
			n_detected_ell_2 = 0;

		if(n_detected_ell_1 == 1 || n_detected_ell_2 == 1)
			status = 1;
		else
		{
			status = 0;
			non_n_event = 1;
			switch(pmt_id)
			{
			case PMT_ID_0:
				cpsEvent.non_n_events_0++;
				break;
			case PMT_ID_1:
				cpsEvent.non_n_events_1++;
				break;
			case PMT_ID_2:
				cpsEvent.non_n_events_2++;
				break;
			case PMT_ID_3:
				cpsEvent.non_n_events_3++;
				break;
			default:
				status = -1;
				break;
			}
		}

		//send the result of these checks to the utility module
		IncNeutronTotal( pmt_id, n_detected_ell_1, n_detected_ell_2, non_n_event, n_high_e, m_previous_1sec_interval_time);
	}

	return status;
}
